/**
 * OpenMOHAA MCP Server - Config Manager Module
 * Handles game configuration files, autoexec, and settings
 */

import { existsSync, readFileSync, writeFileSync, mkdirSync, readdirSync, statSync, copyFileSync } from 'fs';
import { join, dirname, basename } from 'path';

export interface ConfigFile {
  name: string;
  path: string;
  content: string;
  modified: Date;
}

export interface ParsedConfig {
  binds: Record<string, string>;
  cvars: Record<string, string>;
  aliases: Record<string, string>;
  execs: string[];
  other: string[];
}

export class ConfigManager {
  private gameDir: string;
  private modDir: string;

  constructor(gameDir: string, modDir = 'main') {
    this.gameDir = gameDir;
    this.modDir = modDir;
  }

  /**
   * Set the mod directory
   */
  setModDir(modDir: string): void {
    this.modDir = modDir;
  }

  /**
   * Get the config directory path
   */
  getConfigDir(): string {
    return join(this.gameDir, this.modDir);
  }

  /**
   * Read a config file
   */
  readConfig(filename: string): ConfigFile | null {
    const filePath = join(this.getConfigDir(), filename);
    
    if (!existsSync(filePath)) {
      return null;
    }

    const stats = statSync(filePath);
    const content = readFileSync(filePath, 'utf-8');

    return {
      name: filename,
      path: filePath,
      content,
      modified: stats.mtime,
    };
  }

  /**
   * Write a config file
   */
  writeConfig(filename: string, content: string): { success: boolean; path: string; message: string } {
    const configDir = this.getConfigDir();
    const filePath = join(configDir, filename);

    try {
      if (!existsSync(configDir)) {
        mkdirSync(configDir, { recursive: true });
      }

      writeFileSync(filePath, content, 'utf-8');

      return {
        success: true,
        path: filePath,
        message: `Config saved: ${filename}`,
      };
    } catch (error) {
      return {
        success: false,
        path: filePath,
        message: `Failed to save config: ${error}`,
      };
    }
  }

  /**
   * List all config files
   */
  listConfigs(extension = '.cfg'): ConfigFile[] {
    const configDir = this.getConfigDir();
    const configs: ConfigFile[] = [];

    if (!existsSync(configDir)) {
      return configs;
    }

    const files = readdirSync(configDir);
    for (const file of files) {
      if (file.endsWith(extension)) {
        const filePath = join(configDir, file);
        const stats = statSync(filePath);
        
        configs.push({
          name: file,
          path: filePath,
          content: '', // Don't load content in listing
          modified: stats.mtime,
        });
      }
    }

    return configs.sort((a, b) => a.name.localeCompare(b.name));
  }

  /**
   * Parse a config file into structured data
   */
  parseConfig(content: string): ParsedConfig {
    const parsed: ParsedConfig = {
      binds: {},
      cvars: {},
      aliases: {},
      execs: [],
      other: [],
    };

    const lines = content.split('\n');
    
    for (const line of lines) {
      const trimmed = line.trim();
      
      // Skip empty lines and comments
      if (!trimmed || trimmed.startsWith('//')) {
        continue;
      }

      // Parse bind commands
      const bindMatch = trimmed.match(/^bind\s+"?([^"\s]+)"?\s+"?(.+?)"?\s*$/i);
      if (bindMatch) {
        parsed.binds[bindMatch[1]] = bindMatch[2];
        continue;
      }

      // Parse alias commands
      const aliasMatch = trimmed.match(/^alias\s+"?([^"\s]+)"?\s+"?(.+?)"?\s*$/i);
      if (aliasMatch) {
        parsed.aliases[aliasMatch[1]] = aliasMatch[2];
        continue;
      }

      // Parse exec commands
      const execMatch = trimmed.match(/^exec\s+"?(.+?)"?\s*$/i);
      if (execMatch) {
        parsed.execs.push(execMatch[1]);
        continue;
      }

      // Parse seta/set/setu commands (cvars)
      const cvarMatch = trimmed.match(/^(?:seta?|setu?)\s+"?([^"\s]+)"?\s+"?(.+?)"?\s*$/i);
      if (cvarMatch) {
        parsed.cvars[cvarMatch[1]] = cvarMatch[2];
        continue;
      }

      // Parse simple cvar assignments
      const simpleMatch = trimmed.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\s+"?(.+?)"?\s*$/);
      if (simpleMatch && !['bind', 'alias', 'exec', 'set', 'seta', 'setu'].includes(simpleMatch[1].toLowerCase())) {
        parsed.cvars[simpleMatch[1]] = simpleMatch[2];
        continue;
      }

      parsed.other.push(trimmed);
    }

    return parsed;
  }

  /**
   * Generate config file content from parsed data
   */
  generateConfig(parsed: ParsedConfig): string {
    const lines: string[] = [];

    // Add header
    lines.push('// Generated by OpenMOHAA MCP Server');
    lines.push(`// ${new Date().toISOString()}`);
    lines.push('');

    // Add cvars
    if (Object.keys(parsed.cvars).length > 0) {
      lines.push('// CVars');
      for (const [key, value] of Object.entries(parsed.cvars)) {
        lines.push(`seta ${key} "${value}"`);
      }
      lines.push('');
    }

    // Add binds
    if (Object.keys(parsed.binds).length > 0) {
      lines.push('// Key Bindings');
      for (const [key, value] of Object.entries(parsed.binds)) {
        lines.push(`bind ${key} "${value}"`);
      }
      lines.push('');
    }

    // Add aliases
    if (Object.keys(parsed.aliases).length > 0) {
      lines.push('// Aliases');
      for (const [key, value] of Object.entries(parsed.aliases)) {
        lines.push(`alias ${key} "${value}"`);
      }
      lines.push('');
    }

    // Add exec commands
    if (parsed.execs.length > 0) {
      lines.push('// Exec');
      for (const exec of parsed.execs) {
        lines.push(`exec ${exec}`);
      }
      lines.push('');
    }

    // Add other commands
    if (parsed.other.length > 0) {
      lines.push('// Other');
      for (const cmd of parsed.other) {
        lines.push(cmd);
      }
    }

    return lines.join('\n');
  }

  /**
   * Get/create autoexec.cfg
   */
  getAutoexec(): ConfigFile {
    const config = this.readConfig('autoexec.cfg');
    
    if (config) {
      return config;
    }

    // Create default autoexec
    const defaultContent = `// autoexec.cfg - Executed on game startup
// Add your custom settings below

`;

    this.writeConfig('autoexec.cfg', defaultContent);
    
    return {
      name: 'autoexec.cfg',
      path: join(this.getConfigDir(), 'autoexec.cfg'),
      content: defaultContent,
      modified: new Date(),
    };
  }

  /**
   * Append to autoexec.cfg
   */
  appendToAutoexec(commands: string): { success: boolean; message: string } {
    const autoexec = this.getAutoexec();
    const newContent = autoexec.content + '\n' + commands;
    
    return this.writeConfig('autoexec.cfg', newContent);
  }

  /**
   * Set a cvar in autoexec.cfg
   */
  setCvarInAutoexec(name: string, value: string): { success: boolean; message: string } {
    const autoexec = this.getAutoexec();
    const parsed = this.parseConfig(autoexec.content);
    
    parsed.cvars[name] = value;
    
    const newContent = this.generateConfig(parsed);
    return this.writeConfig('autoexec.cfg', newContent);
  }

  /**
   * Add a key binding to autoexec.cfg
   */
  setBindInAutoexec(key: string, command: string): { success: boolean; message: string } {
    const autoexec = this.getAutoexec();
    const parsed = this.parseConfig(autoexec.content);
    
    parsed.binds[key] = command;
    
    const newContent = this.generateConfig(parsed);
    return this.writeConfig('autoexec.cfg', newContent);
  }

  /**
   * Create a backup of a config file
   */
  backupConfig(filename: string): { success: boolean; backupPath: string; message: string } {
    const config = this.readConfig(filename);
    
    if (!config) {
      return {
        success: false,
        backupPath: '',
        message: `Config not found: ${filename}`,
      };
    }

    const backupName = `${filename}.${Date.now()}.bak`;
    const backupPath = join(this.getConfigDir(), backupName);

    try {
      copyFileSync(config.path, backupPath);
      return {
        success: true,
        backupPath,
        message: `Backup created: ${backupName}`,
      };
    } catch (error) {
      return {
        success: false,
        backupPath: '',
        message: `Failed to create backup: ${error}`,
      };
    }
  }

  /**
   * Restore a config from backup
   */
  restoreConfig(backupFilename: string): { success: boolean; message: string } {
    const configDir = this.getConfigDir();
    const backupPath = join(configDir, backupFilename);

    if (!existsSync(backupPath)) {
      return {
        success: false,
        message: `Backup not found: ${backupFilename}`,
      };
    }

    // Extract original filename from backup name
    const originalName = backupFilename.replace(/\.\d+\.bak$/, '');
    const originalPath = join(configDir, originalName);

    try {
      copyFileSync(backupPath, originalPath);
      return {
        success: true,
        message: `Restored ${originalName} from ${backupFilename}`,
      };
    } catch (error) {
      return {
        success: false,
        message: `Failed to restore: ${error}`,
      };
    }
  }

  /**
   * List all config backups
   */
  listBackups(): string[] {
    const configDir = this.getConfigDir();
    
    if (!existsSync(configDir)) {
      return [];
    }

    const files = readdirSync(configDir);
    return files.filter(f => f.endsWith('.bak')).sort().reverse();
  }

  /**
   * Validate a config file syntax
   */
  validateConfig(content: string): { valid: boolean; errors: string[]; warnings: string[] } {
    const errors: string[] = [];
    const warnings: string[] = [];
    const lines = content.split('\n');

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      const lineNum = i + 1;

      // Skip empty lines and comments
      if (!line || line.startsWith('//')) {
        continue;
      }

      // Check for unbalanced quotes
      const quoteCount = (line.match(/"/g) || []).length;
      if (quoteCount % 2 !== 0) {
        errors.push(`Line ${lineNum}: Unbalanced quotes`);
      }

      // Check for common typos
      if (line.match(/^set\s+[a-z]/i) && !line.match(/^(set|seta|setu)\s/i)) {
        warnings.push(`Line ${lineNum}: Did you mean 'set' or 'seta'?`);
      }

      // Check for deprecated commands
      if (line.match(/^(vid_restart|snd_restart)\s*$/i)) {
        warnings.push(`Line ${lineNum}: ${line} in config may cause issues on startup`);
      }
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Create a preset config
   */
  createPreset(name: string, settings: Record<string, string>): { success: boolean; path: string; message: string } {
    const parsed: ParsedConfig = {
      binds: {},
      cvars: settings,
      aliases: {},
      execs: [],
      other: [],
    };

    const content = this.generateConfig(parsed);
    const filename = `preset_${name}.cfg`;
    
    return this.writeConfig(filename, content);
  }

  /**
   * Get graphics presets
   */
  getGraphicsPresets(): Record<string, Record<string, string>> {
    return {
      low: {
        r_mode: '3',
        r_fullscreen: '1',
        r_texturebits: '16',
        r_depthbits: '16',
        r_stencilbits: '0',
        r_vertexlight: '1',
        r_dynamiclight: '0',
        r_shadows: '0',
        cg_shadows: '0',
        r_picmip: '2',
        r_detailtextures: '0',
      },
      medium: {
        r_mode: '4',
        r_fullscreen: '1',
        r_texturebits: '32',
        r_depthbits: '24',
        r_stencilbits: '8',
        r_vertexlight: '0',
        r_dynamiclight: '1',
        r_shadows: '1',
        cg_shadows: '1',
        r_picmip: '1',
        r_detailtextures: '1',
      },
      high: {
        r_mode: '6',
        r_fullscreen: '1',
        r_texturebits: '32',
        r_depthbits: '24',
        r_stencilbits: '8',
        r_vertexlight: '0',
        r_dynamiclight: '1',
        r_shadows: '2',
        cg_shadows: '2',
        r_picmip: '0',
        r_detailtextures: '1',
      },
      ultra: {
        r_mode: '8',
        r_fullscreen: '1',
        r_texturebits: '32',
        r_depthbits: '24',
        r_stencilbits: '8',
        r_vertexlight: '0',
        r_dynamiclight: '1',
        r_shadows: '2',
        cg_shadows: '3',
        r_picmip: '0',
        r_detailtextures: '1',
        r_ext_texture_filter_anisotropic: '1',
      },
    };
  }

  /**
   * Apply a graphics preset
   */
  applyGraphicsPreset(preset: 'low' | 'medium' | 'high' | 'ultra'): { success: boolean; message: string } {
    const presets = this.getGraphicsPresets();
    const settings = presets[preset];

    if (!settings) {
      return { success: false, message: `Unknown preset: ${preset}` };
    }

    // Add all settings to autoexec
    for (const [cvar, value] of Object.entries(settings)) {
      this.setCvarInAutoexec(cvar, value);
    }

    return { success: true, message: `Applied ${preset} graphics preset` };
  }
}

export default ConfigManager;
